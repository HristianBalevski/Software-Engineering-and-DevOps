# Software-Engineering-and-DevOps

A comprehensive course combining Software Engineering principles with DevOps practices to streamline development and deployment processes.

[Click here for more information about the course](https://softuni.bg/trainings/4851/software-engineering-and-devops-january-2025)

![DevOps](https://github.com/user-attachments/assets/63d5721d-00e0-4af1-85a9-5ba6a4442eb7)

# 01. Software Engineering Fundamentals

## A) Software Development Lifecycle (SDLC)

## Основен процес

1. **Изисквания** → **Дизайн** → **Код** → **Тестване** → **Деплой (пускане в употреба)**

### Ключови точки

- **Coding != Software Engineering**:
  - Начинаещите често приравняват "кодене == разработка".
  - Софтуерното инженерство не е само писане на код.
  - Коденето обхваща едва **20%-30%** от активностите в един проект.
  - Жизненият цикъл на разработка включва много повече:
    - Анализ на изисквания
    - Софтуерен дизайн
    - Тестване, QA, интеграция
    - Ревюта, документиране, управление и деплой
  - **Важно**: Най-ключовите решения за софтуера се вземат по време на анализа на изискванията и фазата на дизайна.

## Софтуерно инженерство

- **Цел**: Създаване на софтуер по професионален, предвидим и управляем начин.
- **Задачи**:
  - Дефиниране на изискванията към софтуера
  - Създаване на софтуерен дизайн
  - Конструиране на софтуера
  - Тестване и осигуряване на качеството (QA)
  - Деплой на софтуера
  - Поддръжка на софтуера
  - Управление на процеса на разработка

---

## Жизнен цикъл на разработка на софтуер (SDLC)

### Стъпки в процеса

1. **Анализ и дефиниране на изисквания**
2. **Създаване на архитектура и дизайн**
3. **Конструиране на софтуера (кодене)**
4. **Тестване и QA**
5. **Деплой на софтуера**
6. **Поддръжка на софтуера**

### Методологии

Управляват процеса на разработка чрез определени принципи и практики, които гарантират ефективност и предвидимост.

## B) Software Requirements Analysis

## Софтуерни изисквания

- **Описание**:
  - Софтуерните изисквания описват функционалността на софтуера.
  - Отговарят на въпроса **"Какво трябва да прави?"**, а не **"Как ще го прави?"**.
  - Определят ограниченията върху системата.
- **Видове изисквания**:
  - **Функционални изисквания**:
    - Описват функциите на продукта, които позволяват на потребителите да изпълняват своите задачи.
  - **Нефункционални изисквания**:
    - Свързани с надеждност, ефективност, използваемост, поддръжка и други качества на системата.

---

## Анализ на изискванията (Requirements Analysis)

- **Процес**:

  - Започва с идея за системата.
  - Клиентите често имат обща представа, но може да липсват конкретни детайли.
  - Изискванията първоначално са груби и се прецизират в хода на разработката.
  - **Важно**: Изискванията се променят постоянно!

- **Резултати от анализа**:
  - Документиране на изискванията:
    - **User stories** (потребителски истории)
    - **UI прототип** (визуални макети на потребителския интерфейс)
    - **Спецификация на софтуерните изисквания (SRS)** или неформално описание на системата.
  - Документацията трябва да бъде:
    - **Ясна**
    - **Стегната**
    - **Недвусмислена**

### UI Prototype – Example

<img width="1509" alt="Prototype Example" src="https://github.com/user-attachments/assets/10b3e738-f233-4d2b-8ceb-54a21c346825" />

### SRS – Example

<img width="1587" alt="SRS Example" src="https://github.com/user-attachments/assets/12cb227d-d30a-461a-b94c-4eeaddd7b323" />

### User Story – Example

<img width="1541" alt="User Example" src="https://github.com/user-attachments/assets/82f5ecb5-e3d1-4a76-9274-6169eb12503a" />

## Промени в софтуерните изисквания във времето

### Основни точки

- **Трудности при дефиниране на изискванията**:

  - Трудно е да се опишат и документират изискванията по изчерпателен начин.
  - Добре дефинираните изисквания пестят време и средства, но са трудни за постигане.

- **Динамика на изискванията**:

  - Изискванията винаги се променят по време на проекта.
  - **Добре изработените изисквания**:
    - Намаляват нуждата от промени.
    - Подобряват ефективността на проекта.

- **Методи за справяне с промени**:
  - **UI прототипи**:
    - Значително намаляват броя на промените, като визуализират очакванията на клиента.
  - **Agile методологии**:
    - Гъвкави към променящите се изисквания и адаптивни към новите нужди.
  - **Инструменти за проследяване на потребителски истории**:
    - Улесняват управлението на променящите се изисквания.

## C) Software Architecture and Design

## Софтуерна архитектура и софтуерен дизайн

### Софтуерна архитектура и дизайн

- **Софтуерната архитектура**:

  - Технически описания (напр. диаграми) за това как системата реализира изискванията.
  - Описва подсистемите, техните отговорности и взаимодействия.
  - Представлява високо ниво на инфраструктура на софтуерната система.
  - **Добра софтуерна архитектура**:
    - Улеснява поддръжката.
    - Подобрява мащабируемостта.

- **Софтуерният дизайн**:
  - Описва дизайна на системата на по-ниско ниво:
    - Функции на отделните модули, класове и др.
  - Използва **дизайн шаблони**:
    - Доказани решения за повтарящи се проблеми.
    - Фундаментални за софтуерното инженерство.

---

### Системна архитектура

- **Описание**:

  - Концептуален модел, който описва:
    - Как системата ще бъде разделена на модули (подсистеми).
    - Отговорностите на всеки модул.
    - Взаимодействието между модулите.
    - Платформи, технологии и комуникационни протоколи.

- **Характеристики**:
  - Може да бъде формална или неформална (обикновено неформална).
  - Основно съдържа диаграми и схеми, които служат като чертежи.

## System Architecture Diagram

<img width="1057" alt="System Architecture Diagram" src="https://github.com/user-attachments/assets/f558143c-8619-4742-8707-80b86b01aef0" />

## Software Architecture Diagram

<img width="968" alt="Software Architecture Diagram" src="https://github.com/user-attachments/assets/67be162b-3380-48ab-8121-0de336c171c5" />

## Софтуерен дизайн

### Подробен дизайн (Detailed Design)

- **Описание**:
  - Описва вътрешната структура на модулите.
  - Включва:
    - Подкомпоненти.
    - Интерфейси.
    - Процесен дизайн.
    - Дизайн на данни.

---

### Обектно-ориентиран дизайн (Object-Oriented Design)

- **Описание**:

  - Описва:
    - Класовете и техните отговорности.
    - Връзките, зависимостите и взаимодействията между класовете.
  - Обикновено се представя чрез **UML диаграми**.

- **Вътрешен дизайн на класовете**:
  - Описва:
    - Методи.
    - Отговорности.
    - Алгоритми.
    - Взаимодействия между методите и други класове.

## UML Class Diagram

<img width="1544" alt="UML Class Diagram" src="https://github.com/user-attachments/assets/21d3a4a4-1148-4fe6-acfc-72079498a92f" />

## Flowchart Diagram

<img width="1544" alt="Flowchart Diagram" src="https://github.com/user-attachments/assets/762fff01-d457-472c-85b6-79dcf55d8fb4" />

## Документ за софтуерен дизайн (Software Design Document - SDD)

### Какво представлява SDD?

- **Формално описание** на архитектурата и дизайна на системата.
- **Важност**:
  - Основен елемент в процеса на разработка на софтуер.
  - Улеснява комуникацията между екипите.
  - Използва се за бъдещи справки.
  - Гарантира, че целият екип има ясна представа за дизайна на системата.
  - Особено полезен при въвеждане на нови членове в екипа.

---

### Какво съдържа SDD?

1. **Архитектурен дизайн**:
   - Описание на модулите и тяхното взаимодействие (диаграма).
2. **За всеки модул**:
   - Дизайн на процесите (диаграми).
   - Дизайн на данните (E/R диаграма).
3. **Обектно-ориентиран дизайн**:
   - Класови диаграми, показващи класовете, техните свойства, методи и взаимодействия.

## D) Software ConstructionImplementation, Unit Testing, Debugging, Integration

## Софтуерна конструкция (Software Construction)

### Фаза на конструкция

- **Описание**:
  - Разработчиците изграждат софтуера; често наричана "фаза на имплементация".
- **Ключови дейности**:
  - Дизайн на методи.
  - Писане на изходния код.
  - Тестване и дебъгване.
  - Писане на модулни тестове.
  - Ревюта и инспекции на кода.
  - Интеграция на класове и модули.

---

### Писане на кода (Writing the Code)

- **Кодиране**:
  - Процес на писане на програмен код, стартирането и отстраняването на грешки.
  - Кодът следва установената архитектура и дизайн.
  - Резултатът от конструкционния процес е изходният код.
  - Кодът често включва тестове:
    - **Модулни тестове**.
    - **Интеграционни тестове**.

---

### Тестване на кода (Testing the Code)

- **Процес**:
  - Проверява дали разработеният софтуер съответства на изискванията.
  - Открива дефекти (бъгове).
- **Видове тестване**:
  - **Системно тестване**: извършва се от QA инженери.
  - **Модулно / интеграционно тестване**: извършва се от разработчици.
- **Автоматизирано тестване**:
  - Повтаряемо и изпълнявано многократно.
  - Подобрява ефективността на тестването.

---

### Дебъгване (Debugging)

- **Описание**:
  - Процес на намиране и отстраняване на идентифицирани бъгове.
  - Извършва се от разработчиците.
- **Стъпки при дебъгване**:
  1. Откриване на дефекта в кода.
  2. Определяне на източника на проблема.
  3. Локализиране на конкретното място в кода.
  4. Отстраняване на дефекта чрез промяна на кода.
  5. Тестване на поправката.
  6. Писане на модулен тест за дефекта, за да се предотврати повторната му поява.

---

### Дейности по верификация на софтуера (Software Verification Activities)

- **Инспекции**:
  - Преглед на изисквания, дизайн или код за ранно откриване на проблеми.
  - Извършва се от опитни разработчици или QA инженери.
- **Код ревюта**:
  - Преглед на кода от друг разработчик за откриване на грешки и подобрения.
- **Статичен анализ**:
  - Софтуерни инструменти проверяват изходния код за проблеми:
    - Сигурност, качество на кода, потенциални грешки и др.
- **Динамичен анализ**:
  - Проверява кода по време на изпълнение за проблеми:
    - Проблеми с паметта, слаба производителност, аритметични грешки и др.

---

### Код ревюта (Code Reviews)

- **Описание**:
  - Оценка на изходния код и други артефакти от друг разработчик.
- **Цели**:
  - Идентифициране на бъгове.
  - Подобряване на качеството на кода.
  - Насърчаване на най-добрите практики.
  - Помагат на разработчиците да учат един от друг.
- **Формати**:
  - Формални или неформални.
  - В реално време или офлайн.
- **Инструменти**:
  - Пример: **GitHub Pull Requests**.
  - Коментиране, предлагане на подобрения, одобрение или отхвърляне на кода.

---

### Интеграция на софтуер (Software Integration)

- **Описание**:
  - Комбиниране на множество софтуерни системи за безпроблемна работа.
  - Включва обмен на данни между системите.
- **Ползи**:
  - Подобрява производителността.
  - Намалява дублирането на усилия.
  - Повишава ефективността.
- **Процес**:
  - Компилация, стартиране и деплой на отделни модули като една система.
  - Интеграционно тестване за откриване на дефекти.

## Software Integration Strategies

<img width="1572" alt="Software Integration Strategies" src="https://github.com/user-attachments/assets/fcf1cf39-7822-4d31-ba4e-b89b8e73c43d" />

## Непрекъсната интеграция (Continuous Integration - CI)

### Какво представлява CI?

- **Цел**:
  - Често интегриране на кода от различни разработчици (няколко пъти на ден).
  - Автоматизирано изграждане и тестване на софтуера.
- **Процес**:
  - Активира се при **Git push** в определен branch.
  - Открива интеграционни проблеми и бъгове на ранен етап.
  - Непрекъснато поддържа качеството на софтуера.

---

### Предимства на CI

1. **Ранно откриване на проблеми**:
   - Намаляване на времето и усилията за отстраняване на грешки.
2. **Подобрено качество на софтуера**:
   - Автоматизирани тестове гарантират стабилност при всяка промяна.
3. **Гъвкавост**:
   - Лесно адаптиране към промени в кода.

---

### Инструменти за CI

- **Популярни CI системи**:
  - **Jenkins**
  - **GitHub Actions**
  - **TeamCity**
  - **Azure Pipelines**

### Практически съвети

- Настройте CI така, че автоматизираните тестове и проверки да се изпълняват при всяка промяна в кода.
- Уверете се, че всички разработчици работят по общи стандарти, за да се избегнат проблеми при интеграция.

## CI/CD Pipeline

<img width="1572" alt="CD Pipeline" src="https://github.com/user-attachments/assets/3e86ce0d-1937-4881-b7ec-8580365d765e" />

## E) Software Quality Assurance (QA)Software Quality, Testing, QA Process

## Осигуряване на качество на софтуера (Software Quality Assurance - QA)

### Какво представлява QA?

- **Цел**:
  - Минимизиране на софтуерните дефекти.
  - Гарантиране, че софтуерът се държи според очакванията.
- **Характеристики**:
  - Дефектите се докладват и проследяват чрез система за следене на бъгове.
  - QA се извършва от инженери по осигуряване на качество (QA инженери).
  - Свързано с **непрекъсната интеграция и доставка** (CI/CD).

---

### QA инженери (Quality Assurance Engineers)

- **Роля**:
  - Гарантират качеството на софтуера.
- **Дейности**:
  - Планират и изпълняват тестови активности.
  - Тестват функционалността, UX и други аспекти на софтуера.
  - Създават тестови планове, проектират тестови сценарии и изпълняват тестове.
  - Разработват и изпълняват скриптове за автоматизирано тестване.
  - Докладват и проследяват дефекти (бъгове) и техния жизнен цикъл.
  - Извършват регресионно тестване при отстраняване на бъгове.
  - Проследяват процеса на разработка и неговото качество.
  - Преглеждат изискванията, дизайна и кода.
  - Изграждат и наблюдават CI/CD процеси, следят QA метрики.

---

### Бъгове и проследяване на бъгове (Bugs and Bug Tracking)

- **Какво представлява бъгът?**
  - Дефект в изходния код, изискванията или дизайна, който води до неправилно поведение.
- **Процес**:
  - Бъговете се откриват (обикновено от QA инженери) и се проследяват чрез инструменти за управление на задачи.
  - **Примери за инструменти**:
    - **Jira**, **GitHub Issues**.
- **Жизнен цикъл на бъг**:
  - **new → assigned/rejected → fixed → closed/reopened**.

---

### Тестов план, тестови сценарии и тестови случаи

- **Тестов план**:
  - Ръководен документ, който описва подхода за тестване, среди, график и критерии за приемане, за да се гарантира качеството на софтуера.
- **Тестови сценарии**:
  - Високо ниво на описание или история, представяща функционалността или характеристиката, която трябва да се тества.
- **Тестови случаи**:
  - Подробни, стъпка по стъпка инструкции за проверка на конкретни условия или функции в софтуера, базирани на свързаните тестови сценарии.

---

### Ръчно и автоматизирано тестване

- **Ръчно тестване**:
  - Ръчно взаимодействие със софтуера:
    - Попълване на форми, кликване, проверка на резултатите.
- **Автоматизирано тестване**:
  - Тестови случаи, написани като код.
  - Автоматизираното тестване спестява време и намалява вероятността от човешки грешки.

## F) Deployment and Maintenance

## Софтуерно внедряване (Software Deployment)

### Какво представлява софтуерното внедряване?

- **Описание**:
  - Процесът на предоставяне на софтуера на потребителите.
  - Включва:
    - Компилация.
    - Опаковане.
    - Инсталиране.
    - Конфигуриране.
    - Стартиране на софтуера в клиентската среда.
  - **Цел**: Да се направи софтуерът достъпен за крайните потребители.

---

### Варианти на внедряване

- **Уеб приложения**:
  - Внедряване на нова версия на уеб сървъри.
- **Мобилни приложения**:
  - Публикуване на нова версия в магазините за приложения.
- **Десктоп приложения**:
  - Пускане на нов инсталатор за клиентите.

---

### Непрекъснато внедряване (Continuous Deployment - CD)

- **Описание**:
  - Автоматично внедряване на софтуера след всяка промяна (commit).
  - **Предимства**:
    - Гарантира, че направените промени са внедряеми.
    - Подобрява скоростта и ефективността на предоставяне на нови версии на софтуера.

## Видове среди за разработка и тестване

### 1. **Разработваща среда (Dev Environment)**

- **Описание**:
  - Използва се от разработчиците за създаване и тестване на функционалност.
- **Характеристики**:
  - Няма клиентски данни.

---

### 2. **Тестова среда (Test Environment)**

- **Описание**:
  - Използва се от QA инженери за провеждане на тестове.
- **Характеристики**:
  - Без клиентски данни.

---

### 3. **Преходна среда (Staging Environment)**

- **Описание**:
  - Използва се от QA инженери и/или клиенти за потребителско приемателно тестване (UAT).
- **Характеристики**:
  - Ограничени данни от производствената среда.

---

### 4. **Производствена среда (Production Environment)**

- **Описание**:
  - Използва се от крайните потребители.
- **Характеристики**:
  - Пълни данни от производствената среда.

## Container-Based Deployment Environments

## Контейнери и облачни технологии

### Как контейнери и облаци улесняват средите?

- **Контейнери**:

  - Осигуряват изолирани и леки среди за приложения.
  - Гарантират, че всички зависимости са опаковани заедно с приложението.
  - Примери: **Docker**, **Podman**.

- **Облачни технологии**:
  - Предоставят готови за използване среди и ресурси за разработка, тестване и внедряване.
  - Улесняват мащабируемостта, конфигурирането и управлението на ресурсите.
  - Примери: **AWS**, **Google Cloud**, **Microsoft Azure**.

### Ползи:

1. **Бързо създаване на среди**:
   - Лесно настройване на идентични среди за разработка, тестване и продукция.
2. **Консистентност**:
   - Сигурност, че всички среди са еднакви.
3. **Мобилност**:
   - Контейнерите и облаците позволяват преносимост между различни платформи.
4. **Автоматизация**:
   - Улесняват CI/CD процесите за бързо внедряване и тестване.

<img width="1572" alt="Container-Based Deployment Environments" src="https://github.com/user-attachments/assets/56a1c34f-5769-4482-b18b-cd8c5576c26c" />

## Поддръжка на софтуера (Software Maintenance)

### Какво представлява поддръжката на софтуера?

- **Описание**:
  - Процесът на промяна на система след нейната публикация.
- **Причини за промени**:
  1. **Отстраняване на грешки**:
     - Поправка на бъгове.
     - Корекция на уязвимости в сигурността.
  2. **Промени в бизнес нуждите**:
     - Добавяне на нови функционалности и изисквания.
  3. **Адаптиране към нови среди**:
     - Обновяване за работа с нов хардуер, платформи или софтуер.

---

### Типичен процес на промяна

1. **Анализ**.
2. **Дефиниране на изисквания**.
3. **Добавяне в backlog**.
4. **Приоритизация на задачите**.
5. **Изпълнение на всяка промяна**:
   - Дизайн / реинженеринг.
   - Кодиране.
   - QA (тестване).
   - Внедряване.

---

## Документация на софтуера (Software Documentation)

### Значение на документацията

- Прави софтуера **по-лесен за поддръжка**.
- Позволява **нови хора** да се включват в екипа с минимални затруднения.

---

### Най-добри практики за документация

1. **Визуализация на процеса**:
   - Използване на проектен борд (напр. Kanban).
2. **Писмени изисквания**:
   - Проследяване чрез система за управление на изискванията.
3. **Дизайн и архитектура**:
   - Документиране чрез Wiki или други инструменти.
4. **Документация на кода**:
   - Коментари и вградена документация в кода.
5. **Управление на тестове и CI системи**:
   - Dashboard за следене на процесите.
6. **Документация за потребителите**:
   - Ръководства за инсталиране, бърз старт и други.

---

## Обобщение

1. **Софтуерно инженерство**:
   - Осигурява знания, процеси, практики и инструменти за всички етапи на жизнения цикъл на разработката (SDLC).
2. **Софтуерни изисквания**:
   - Описват функционалностите на софтуера.
3. **Софтуерен дизайн и архитектура**:
   - Описват структурата на системата – модули и взаимодействия.
4. **Софтуерна конструкция**:
   - Включва кодиране, дебъгване, модулно тестване, код ревюта и интеграция (вкл. CI).
5. **QA**:
   - Осигурява, че софтуерът работи както е предвидено, чрез ръчни и автоматизирани тестове.
6. **Софтуерно внедряване**:
   - Предоставя софтуера на клиентите и преминава през различни среди за внедряване.

---

# 02. Introduction to DevOps and Software Development Methodologies

# What is DevOps?

### Съчетаване на софтуерната разработка и IT екипите

### Какво представлява DevOps?

- **DevOps** е набор от практики, инструменти и философия, които обединяват разработката (**Dev**) и операциите (**Ops**) в един непрекъснат процес.
- Целта е да се обединят хора, процеси и технологии в етапите на планиране, разработка, доставка и поддръжка на приложения.
- DevOps насърчава координацията и сътрудничеството между различни роли, като разработка, IT операции, качествено инженерство и сигурност.

# DevOps Lifecycle

- **Жизненият цикъл на DevOps** (или pipeline) представлява поредица от автоматизирани процеси или работни потоци в рамките на итеративен цикъл на разработка.
- Той отразява процесите, възможностите и инструментите, използвани за разработка (от лявата страна) и операции (от дясната страна).
- Целта е да се обединят двете страни в един плавен и интегриран процес.
- Следва подход на **непрекъснатост** (continuous approach), осигуряващ постоянна интеграция и доставка.

# Continuous Everything

<img width="1132" alt="Continuous Everything" src="https://github.com/user-attachments/assets/b96b7fb6-6559-4da4-a117-b4b42d451328" />

[Source: ](https://medium.com/taptuit/the-eight-phases-of-a-devops-pipeline-fda53ec9bba)

# DevOps Lifecycle Stages

## 1. **Планиране (Plan)**

- Идентифициране на бизнес изискванията.
- Събиране на обратна връзка от крайни потребители.

## 2. **Кодиране (Code)**

- Разработка на кода.
- Готовият код се добавя в общо хранилище.

## 3. **Сглобяване (Build)**

- Кодът се деплойва в тестова среда.
- Извършват се тестове за проверка на функционалността.

## 4. **Тестване (Test)**

- Тестовете гарантират, че промените са стабилни и готови за внедряване.

## 5. **Пускане (Release)**

- Екипът по операции планира пускането.
- Възможно е внедряване на множество версии едновременно.

## 6. **Деплой (Deploy)**

- Изграждане на продукционната среда.
- Публикуване на сглобката в продукция.

## 7. **Операции (Operate)**

- Пускането е вече активно.
- Екипът по операции се грижи за конфигурирането и поддръжката на сървърите.

## 8. **Мониторинг (Monitor)**

- Наблюдение на DevOps pipeline за идентифициране на проблеми и тесни места.

# DevOps Pipeline Phases

DevOps следва подход на непрекъснатост, който включва различни етапи за автоматизация и оптимизация:

## 1. **Непрекъснато разработване (Continuous Development)**

- Включва планиране и кодиране на нови функции.

## 2. **Непрекъсната интеграция (Continuous Integration)**

- Обновяване на кода и добавяне на нови функционалности.
- Целта е плавно интегриране на промените в проекта.

## 3. **Непрекъснато тестване (Continuous Testing)**

- Провеждане на автоматизирани или ръчни тестове, за да се гарантира стабилността на системата.

## 4. **Непрекъснато внедряване (Continuous Deployment)**

- Кодът се автоматично внедрява на продукционни сървъри, без прекъсване на услугите.

## 5. **Непрекъсната обратна връзка (Continuous Feedback)**

- Събиране и анализ на обратната връзка от потребителите за подобряване на бъдещи версии.

## 6. **Непрекъснат мониторинг (Continuous Monitoring)**

- Наблюдение за системни грешки и проблеми с производителността.

## 7. **Непрекъснати операции (Continuous Operations)**

- Автоматизация на стартирането на приложението и неговите актуализации.

# DevOps Tools

<img width="1488" alt="DevOps Tools" src="https://github.com/user-attachments/assets/d019c4d6-157d-4c99-8b3d-d055a7de9de0" />

# DevOps Culture

Културата на **DevOps** представлява съвместен подход към разработката и доставката на софтуер, който набляга на комуникацията, автоматизацията и постоянното усъвършенстване.

## Основни принципи на DevOps културата:

### 1. **Сътрудничество е от ключово значение**

- Всички екипи трябва да комуникират открито и честно относно процесите, приоритетите и предизвикателствата на DevOps.

### 2. **Комуникация и споделена отговорност**

- Екипите се подравняват, поемат отговорност и участват активно в различни етапи от жизнения цикъл, а не само в тези, които са пряко свързани с тяхната роля.

### 3. **Гъвкавост и кратки цикли на внедряване**

- DevOps екипите остават гъвкави чрез внедряване на софтуер в кратки цикли, което осигурява бърза реакция на промените.

### 4. **Постоянно учене и подобрение**

- Екипите се стремят непрекъснато да учат и да подобряват своите процеси, за да постигат по-добри резултати.

# DevOps Engineers

DevOps инженерите играят ключова роля в осигуряването на ефективно внедряване и поддръжка на софтуерни приложения.

## Основни отговорности:

### 1. **Внедряване и поддръжка**

- Отговарят за процесите по внедряване и поддръжка на софтуерните приложения.

### 2. **Сътрудничество с екипите**

- Работят в тясно сътрудничество с екипите за разработка и операции, за да постигнат общи цели.

### 3. **Комбиниране на умения**

- Съчетават техническите си знания с добре развити "меки" умения, като комуникация и работа в екип.

### 4. **Разбиране на жизнения цикъл и културата на DevOps**

- Притежават задълбочени познания за жизнения цикъл на разработката, културата, практиките и инструментите на DevOps.

# Role of DevOps Engineers

DevOps инженерите изпълняват ключови задачи, които осигуряват гладкото функциониране на приложенията и инфраструктурата.

## Задължения и отговорности:

### 1. **Автоматизиране на процеси**

- Оптимизират работните процеси чрез автоматизация, за да ускорят разработката и внедряването.

### 2. **Управление и поддръжка на инфраструктурата**

- Поддържат инфраструктурната система стабилна и ефективна.

### 3. **Мониторинг на производителността**

- Наблюдават системите, за да гарантират оптимална производителност и бърза реакция на проблеми.

### 4. **Осигуряване на сигурност**

- Гарантират сигурността на софтуера, като защитават данните и предотвратяват уязвимости.

### 5. **Мащабиране и достъпност на системите**

- Работят с разработчиците, за да осигурят мащабируемост на системите и непрекъсната достъпност на услугите.

# DevOps Practices

DevOps подходът е изключително полезен на всеки етап от жизнения цикъл на приложението, осигурявайки ефективност, качество и бързина.

### 1. **Непрекъсната интеграция и доставка (CI/CD)**

- Автоматизира процесите по интеграция на код и внедряване, за да се осигури по-бързо пускане на нови функции.

### 2. **Инфраструктура като код (Infrastructure as Code - IaC)**

- Управление на инфраструктурата чрез код, което позволява автоматизация и последователност при внедряването.

### 3. **Контрол на версиите (Version Control)**

- Използване на системи за контрол на версиите като Git, за да се проследяват промените в кода и да се улесни сътрудничеството.

### 4. **Мониторинг и логове (Monitoring and Logging)**

- Постоянно наблюдение на системите и записване на логове за откриване на проблеми и подобряване на производителността.

### 5. **Автоматизация (Automation)**

- Автоматизиране на повтарящи се задачи за оптимизиране на времето и ресурсите.

### 6. **Гъвкава разработка на софтуер (Agile Software Development)**

- Използване на Agile подходи за бързо адаптиране към промените и непрекъснато подобрение.

<img width="854" alt="DevOps Practices" src="https://github.com/user-attachments/assets/efc798fd-6181-4244-b54c-ed5efaa587d7" />

# CI/CD Pipeline

CI/CD Pipeline е основен елемент на DevOps, който описва пътя на кода от машината на разработчика до продукционната среда. Той включва множество етапи и цели за бързо и надеждно предоставяне на софтуер на потребителите.

## Основни етапи на CI/CD Pipeline:

1. **Разработка (Development)**

   - Писане и създаване на нов код.

2. **Интеграция (Integration)**

   - Редовно обединяване на промените в централизирано хранилище.
   - Промените се валидират чрез автоматизирани тестове.

3. **Тестване (Testing)**

   - Провеждане на тестове за гарантиране на качеството и стабилността на новите промени.

4. **Внедряване (Deployment)**
   - Подготовка и пускане на кода в продукционната среда.

## Цел:

Да се доставят нови функции, актуализации и корекции на потребителите **бързо и надеждно**.

---

## Как CI/CD подпомага организациите:

- **Непрекъсната интеграция (Continuous Integration):**

  - Разработчиците редовно обединяват промените си в централно хранилище, като тези промени се валидират чрез автоматизирани тестове.

- **Непрекъсната доставка (Continuous Delivery):**

  - Промените в кода се подготвят автоматично за пускане в продукция и могат да бъдат внедрени ръчно.

- **Непрекъснато внедряване (Continuous Deployment):**
  - Промените, които преминават успешно през всички етапи на pipeline-а, се внедряват автоматично в продукция (опционално).

---

## Инструменти за CI/CD:

- **GitHub Actions**
- **Jenkins**
- **CircleCI**
- Други популярни платформи, които автоматизират CI/CD процесите.

# Infrastructure as Code (IaC)

**Infrastructure as Code (IaC)** е практика за управление и предоставяне на инфраструктура чрез код, вместо чрез ръчни процеси. Това позволява автоматизация и стандартизация на инфраструктурните ресурси.

## Основни характеристики на IaC:

- **Автоматизирано управление:**

  - Ресурсите се управляват автоматично чрез скриптове или конфигурационни файлове.

- **Консистентност и стандартизация:**
  - IaC премахва грешките, свързани с ръчните настройки, като гарантира, че инфраструктурата е последователно конфигурирана.

## Примери за ресурси, управлявани чрез IaC:

- **Сървъри (Servers):**

  - Създаване, конфигуриране и управление на виртуални или физически сървъри.

- **Операционни системи (Operating Systems):**

  - Инсталация и конфигурация на ОС.

- **Софтуерни платформи (Software Platforms):**

  - Автоматизирано инсталиране на платформи и услуги като уеб сървъри или бази данни.

- **Съхранение (Storage):**

  - Управление на дискови ресурси, хранилища и бекъпи.

- **Мрежови конфигурации (Networking):**

  - Настройка на мрежови връзки, рутери и защитни стени.

- **И други (Etc.):**
  - Всичко свързано с инфраструктурни ресурси.

IaC трансформира начина, по който организациите изграждат и управляват своите системи, като въвежда автоматизация и ефективност във всеки аспект на инфраструктурата.

# IaC Tools

**IaC** използва инструменти, които дефинират инфраструктурните ресурси чрез код или конфигурационни файлове. Това прави възможно тяхното управление по същия начин, както софтуерния код.

## Характеристики на IaC инструментите:

- **Версиониране и автоматизация:**

  - Конфигурационните файлове могат да се поставят под контрол на версиите (version control), да се тестват и да се внедряват автоматично.

- **Инструменти за IaC:**
  - **Ansible**
  - **Puppet**
  - **Chef**
  - **Saltstack**
  - **Terraform**
  - И други популярни решения.

---

## Подходи към IaC:

### 1. **Декларативен подход (Declarative):**

- Определя желаното състояние на системата, т.е. ресурсите, от които се нуждаете, и техните свойства.
- Пример: _„Искам два сървъра с определена конфигурация.“_

### 2. **Императивен подход (Imperative):**

- Дефинира конкретните команди, които трябва да се изпълнят за постигане на желаната конфигурация.
- Пример: _„Създай сървър, инсталирай операционна система, настрой мрежата и т.н.“_

---

Използването на IaC инструменти и подходи помага за постигане на по-голяма ефективност, стандартизация и автоматизация при управлението на инфраструктурата.

# Version Control

**Контролът на версиите** е практика за управление на кода в различни версии, която улеснява преглеждането и възстановяването на промените. Това е ключов компонент за ефективна разработка на софтуер и основа за CI/CD и IaC.

## Основни характеристики на контрола на версиите:

- **Проследяване на ревизии и история на промените:**

  - Запазва всяка индивидуална промяна в специална база данни, което улеснява прегледа и възстановяването на кода.

- **Подобряване на ефективността:**

  - Поддържа бързината и гъвкавостта на екипа, дори при разрастване.

- **Инструменти за контрол на версиите:**
  - **Git**
  - **SVN**
  - **Mercurial**
  - И други популярни инструменти.

---

## Защо контролът на версиите е от съществено значение?

1. **Сигурност за кода:**

   - Действа като мрежа за безопасност, която защитава кода от грешки или загуба.

2. **Подобряване на сътрудничеството:**

   - Позволява на няколко човека да работят едновременно върху един и същ проект.
   - Ускорява разработката чрез ясна комуникация и споделяне на задачи.

3. **Управление на промени:**
   - Контрол на промените в:
     - **Кода**
     - **Конфигурациите**
     - **Дефинициите на инфраструктурата**
     - **Документацията**

---

Контролът на версиите е жизненоважен инструмент за всеки софтуерен проект, като осигурява по-добра координация, бързина и надеждност при разработката.

# Monitoring and Logging

**Мониторингът** осигурява пълна и реална видимост върху състоянието и производителността на цялостната апликационна структура в реално време. Това е ключов процес за предотвратяване на проблеми и гарантиране на безпроблемна работа.

## Основни аспекти на мониторинга:

1. **Събиране и анализ на данни:**

   - Събиране на метрики от приложения, събитийни данни, логове, трасета и други.
   - Анализ на събраните данни за идентифициране на потенциални проблеми.

2. **Задаване на смислени сигнали и аларми:**

   - Настройка на предупреждения за грешки или проблеми в целия pipeline за внедряване.
   - Предупрежденията са "действащи", което позволява на екипа да реагира бързо.

3. **Реагиране в реално време:**
   - DevOps екипите могат да смекчат проблемите в момента на възникване, преди те да ескалират.

---

## Инструменти за мониторинг:

- **ELK Stack**
- **Splunk**
- **Prometheus**
- **Grafana**
- **Alertmanager**
- **Nagios**

---

Мониторингът е жизненоважна част от DevOps, която гарантира стабилност, производителност и навременно разрешаване на проблеми.

# Automation

Екипите в DevOps се стремят да автоматизират максимално голяма част от жизнения цикъл на софтуера, за да се фокусират повече върху писането на код и разработката на нови функционалности.

## Как автоматизацията помага:

1. **Тригериране на автоматизирани процеси:**

   - Дори простото действие като качване на промени в хранилище на изходния код може автоматично да задейства процеси като изграждане, тестване и внедряване.

2. **Предимства на автоматизацията:**
   - **По-бърза доставка на софтуер:** Промените достигат до потребителите по-бързо.
   - **Консистентност и предвидимост:** Процесите са стандартизирани и мащабируеми.
   - **Елиминиране на ръчните задачи:** Екипите не се занимават с отегчителни ръчни операции.

---

## Инструменти за автоматизация:

Различните стъпки в DevOps процеса изискват разнообразни инструменти, които да поддържат автоматизацията във всяка фаза.

---

Автоматизацията е ключов фактор за успеха на DevOps, като подобрява скоростта, качеството и ефективността на разработката.

# Agile Software Development

**Agile** е съвременен подход към разработката на софтуер, който поставя акцент върху бързата адаптация към промени и активното участие на потребителите и екипите.

## Основни принципи на Agile:

1. **Висока адаптивност към промени:**

   - Използване на кратки цикли за пускане на нови версии, което позволява бързо реагиране на промени в изискванията.

2. **Обратна връзка от клиенти и потребители:**

   - Потребителската обратна връзка е основен двигател за подобрение и развитие на продукта.

3. **Сътрудничество в екипа:**
   - Подобрена комуникация и координация между членовете на екипа.

---

## Agile в контекста на DevOps:

- **Повишена автоматизация:**

  - Автоматизираните процеси улесняват бързите итерации и пускането на нови версии.

- **Подобрено сътрудничество:**
  - Обединява различни екипи (разработка, операции, QA) за постигане на обща цел.

---

Agile и DevOps работят заедно, за да осигурят по-бърза, качествена и ефективна разработка и доставка на софтуер.

<img width="642" alt="Agile DevOps" src="https://github.com/user-attachments/assets/8fd0e396-3e4f-4ed8-8b96-6aaa6312770e" />

# DevOps Trends

## Допълнителни DevOps практики за подобряване на жизнения процес

DevOps постоянно се развива, за да отговори на новите изисквания в софтуерната разработка и операциите. Някои от ключовите тенденции включват:

## Основни тенденции:

1. **Повишено внимание към сигурността и съответствието:**

   - Сигурността става интегрална част от DevOps процесите, с акцент върху автоматизацията на проверки за съответствие.

2. **Приемане на архитектура на микросервизи (Microservices):**

   - Микросервизната архитектура позволява по-гъвкаво и мащабируемо разработване и внедряване на приложения.

3. **Еволюция на автоматизацията и изкуствения интелект (AI):**

   - Използване на AI за усъвършенстване на автоматизацията и откриване на проблеми в ранните етапи.

4. **И други...**
   - Тенденциите непрекъснато се разширяват, включвайки нови технологии и практики.

---

## Как тези тенденции подобряват DevOps?

- **Подобрена продуктивност:**
  - Тези иновации помагат на екипите да работят по-ефективно и с по-високо качество.
- **По-бърза адаптация към нови изисквания:**
  - Улесняват бързото внедряване на промени и нови функции.

DevOps движението продължава да трансформира начина, по който софтуерът се разработва, доставя и поддържа.

# DevSecOps

**DevSecOps** представлява разширение на DevOps рамката, където сигурността се възприема като споделена отговорност между всички екипи. Целта е да се интегрират практики за сигурност в приложенията и инфраструктурата още от самото начало.

## Основни характеристики на DevSecOps:

1. **Сигурността като неразделна част от DevOps:**

   - Сигурността не е само задача на един екип, а споделена отговорност за всички участници в разработката и операциите.

2. **Проактивен подход към уязвимостите:**

   - Ранно идентифициране на уязвимости чрез анализ и тестване.

3. **Интеграция на практики за сигурност:**
   - Сигурността се вгражда в приложенията и инфраструктурата още от етапа на проектиране.

---

## Инструменти за сигурност в DevSecOps:

### Статичен анализ (Static Analysis):

- Използва се за анализ на кода без неговото изпълнение.
- **Популярни инструменти:**
  - SonarCube
  - Fortify
  - Veracode
  - Checkmarx

### Динамичен анализ (Dynamic Analysis):

- Изследва приложенията по време на тяхното изпълнение за откриване на уязвимости.
- **Популярни инструменти:**
  - OWASP Zed Attack Proxy
  - Burp Suite
  - Acunetix
  - WebInspect

---

## Ползи от DevSecOps:

- Намаляване на риска от пробиви в сигурността.
- Повишаване на доверието към приложенията.
- Оптимизация на процесите чрез интегриране на сигурността още от началото.

DevSecOps осигурява цялостен подход за защита на приложенията и инфраструктурата в рамките на DevOps практиките.

# DevOps vs DevSecOps

<img width="1444" alt="DevOps vs DevSecOps" src="https://github.com/user-attachments/assets/7d1935db-1358-4476-9c23-5343af018274" />

# Static vs Dynamic Analysis in DevSecOps

Анализът на сигурността е ключова практика в DevSecOps, която включва статичен и динамичен подход за откриване на уязвимости.

---

## Статичен анализ (Static Analysis)

- **Цел:**
  - Идентифициране на уязвимости в сигурността още в началните етапи на разработка.
- **Как се извършва:**

  - Анализиране на кода **без неговото изпълнение**.

- **Ползи:**
  - Улавя потенциални проблеми със сигурността рано, което намалява риска от грешки в по-късните етапи.

---

## Динамичен анализ (Dynamic Analysis)

- **Цел:**

  - Идентифициране на слабости в сигурността по време на работа на приложението.

- **Как се извършва:**

  - Анализ на кода чрез **изпълнение на приложението** в реална или симулирана среда.

- **Ползи:**
  - Откриване на проблеми със сигурността в **реално време**, които не могат да бъдат засечени със статичен анализ.

---

И двата подхода се допълват взаимно, осигурявайки цялостен подход за откриване и отстраняване на уязвимости в сигурността.

# Serverless Computing

**Serverless Computing** е подход, при който бекенд инфраструктурата и операциите се възлагат на доставчик на облачни услуги. Това позволява на разработчиците да се концентрират изцяло върху писането на код, вместо да управляват сървъри.

---

## Основни характеристики на Serverless Computing:

1. **Аутсорсване на инфраструктурата:**

   - Доставчикът на облачни услуги управлява цялата бекенд инфраструктура.
   - Това включва автоматизация на мащабирането и осигуряването на ресурси.

2. **Фокус върху разработката:**

   - Разработчиците могат да се фокусират изцяло върху функционалността на приложението, без да се занимават със сървърни конфигурации.

3. **Гъвкавост и мащабируемост:**
   - Cloud доставчикът осигурява автоматично мащабиране на инфраструктурата в зависимост от нуждите.

---

Serverless Computing предоставя на екипите бързина, ефективност и възможност за фокусиране върху добавянето на стойност към продукта.

<img width="737" alt="Serverless Computing" src="https://github.com/user-attachments/assets/c8922408-f95b-4669-8469-8a6cede218e0" />

# Serverless Computing и Function-as-a-Service (FaaS)

**Serverless Computing** често се асоциира с **Function-as-a-Service (FaaS)**, при който функциите се изпълняват в облачна среда на базата на събития. Този подход предоставя гъвкавост и ефективност при разработката на приложения.

---

## Основни характеристики на Serverless Computing и FaaS:

1. **Събитийно управление (Event-Driven Execution):**

   - Функциите се задействат в отговор на специфични събития, като например:
     - Промени в данни.
     - Заявки от потребители.

2. **Безсъстояние (Stateless Nature):**

   - Serverless функциите са проектирани да бъдат **безсъстояни**.
   - Всяко изпълнение е независимо и не разчита на предишно състояние.

3. **Инструменти за разработка:**
   - Широк набор от налични инструменти, включително:
     - **Фреймуъркове (Frameworks)**
     - **SDKs**
     - **Интерфейси за команден ред (CLIs)**

---

Serverless Computing и FaaS предоставят мащабируема, събитийно базирана архитектура, която е идеална за съвременните приложения с високи изисквания към производителността и ефективността.

# Microservices Architecture

**Микросервизите** представляват архитектурен подход към разработката, при който приложенията се разделят на отделни, слабо свързани услуги. Този подход улеснява разработката, внедряването и мащабирането на софтуер.

---

## Основни характеристики на микросервизите:

1. **Фокус върху конкретни бизнес функции:**

   - Всяка услуга е проектирана да изпълнява определена бизнес задача.

2. **Независима разработка и внедряване:**

   - Всяка услуга може да бъде разработвана, внедрявана и мащабирана независимо от останалите.

3. **Разделяне на екипите:**

   - Разработчиците могат да се разделят на екипи, всеки от които отговаря за определен микросервиз.

4. **Повишена гъвкавост:**
   - Този подход прави процеса на разработка по-гъвкав и лесен за адаптация.

---

## Комуникация между микросервизите:

- **Леки протоколи:**

  - Комуникацията между услугите обикновено се извършва чрез леки протоколи като **HTTP/REST**.

- **Независими технологии:**
  - Всеки микросервиз може да използва собствена технология, програмен език и база данни, в зависимост от специфичните бизнес изисквания.

---

Микросервизната архитектура предоставя на екипите повече гъвкавост, улеснява поддръжката и мащабирането на приложенията, което я прави изключително подходяща за съвременни разработки.

<img width="894" alt="Microservices Architecture" src="https://github.com/user-attachments/assets/500951fa-c915-4a52-b532-027862ea7f63" />

# AIOps and MLOps

**AIOps (Artificial Intelligence for IT Operations)** представлява използването на изкуствен интелект (AI) и машинно обучение (ML) за автоматизация и усъвършенстване на различни IT операции и процеси.

---

## Основни характеристики на AIOps:

1. **Идентифициране на основните проблеми:**

   - AIOps помага за откриването на основните причини за проблеми, които възпрепятстват оперативната продуктивност.

2. **Автоматизация и подобрение:**
   - Чрез AI и ML се автоматизират задачи, които подобряват ефективността и надеждността на IT операциите.

---

## Роля на MLOps:

- **Оптимизация на операции:**
  - MLOps се фокусира върху оптимизацията на оперативните процеси чрез внедряване на модели за машинно обучение.
  - Целта е да се подобри продуктивността на екипите и системите.

---

AIOps и MLOps предоставят интелигентен подход за управление на IT операции, като комбинират автоматизацията с анализа на данни за постигане на по-висока ефективност и надеждност.

<img width="866" alt="Aiops" src="https://github.com/user-attachments/assets/6f3f5e1f-9b0b-4abf-9c75-9b198ac6edab" />

# Обобщение: DevOps

**DevOps** представлява набор от практики, инструменти и културна философия, които автоматизират и интегрират процесите между екипите за софтуерна разработка и IT операции.

---

## Основни характеристики на DevOps:

1. **Жизнен цикъл и фази на pipeline:**

   - DevOps включва **8 етапа на жизнения цикъл** и **7 фази на pipeline**.

2. **Ключови практики:**

   - **CI/CD (Непрекъсната интеграция и доставка)**
   - **Инфраструктура като код (IaC)**
   - **Контрол на версиите (Version Control)**
   - **Мониторинг и логове (Monitoring and Logging)**
   - **Автоматизация (Automation)**
   - **Гъвкава разработка (Agile Software Development)**

3. **Тенденции в DevOps:**
   - **DevSecOps:** Интеграция на сигурността в DevOps.
   - **Микросервизи (Microservices):** Разделяне на приложенията на малки, независими услуги.
   - **Serverless Computing:** Аутсорсване на инфраструктурата към облачни доставчици.
   - **AIOps:** Използване на AI за автоматизация и подобрение на IT операции.

---

DevOps обединява екипите, инструментите и процесите, за да постигне по-голяма ефективност, бързина и надеждност в разработката и поддръжката на софтуер.

---

# 03. Version Control with Git

## Система за контрол на версиите (Version Control System)

**Управление на конфигурацията на софтуера (Software Configuration Management - SCM)** включва използването на системи за контрол на версиите за управление на промените по време на разработката.

---

## Основни характеристики на системата за контрол на версиите:

1. **Контрол на версиите (Version Control System ≈ Source Control System):**

   - Инструмент за управление на промените, направени по време на разработка.

   - Съхранява изходния код и други активи на проекта.

     - Поддържа пълна история на всички промени през времето.

       - Показва кой, кога и защо е направил промяна.

   - Решава конфликти, възникнали при едновременни промени от различни разработчици.

     - Позволява връщане към предишни версии на кода.

---

## Популярни системи за контрол на версиите:

- **Git:**

  - Разпределен контрол на версиите (йерархичен подход).

- **Subversion (SVN):**
  - Централизиран репозиторий (централизиран подход).

## Distributed Version Control (DVC)

<img width="1522" alt="Distributed" src="https://github.com/user-attachments/assets/d19b76ca-8aa2-4527-a148-28214643fcf9" />

## Centralized Version Control (CVC)

<img width="1483" alt="Centralized" src="https://github.com/user-attachments/assets/297e5dae-09e1-48aa-bb1f-e48bed2d63d1" />

# Git: Global Information Tracker

**Git** е най-популярната система за разпределен контрол на версиите, която позволява управление на изходния код както локално, така и дистанционно.

---

## Какво е Git?

1. **Git:**

   - Разпределена система за контрол на версиите.
   - Най-популярният инструмент за контрол на версиите в света.
   - Безплатен и с отворен код.
   - Работи с локални и дистанционни репозитории.
   - Съвместим с Linux, macOS и Windows.

2. **GitHub:**
   - Социална мрежа за разработчици.
   - Безплатна платформа за хостинг на проекти с Git репозиторий.

---

Git е основен инструмент за съвременна разработка на софтуер, осигуряващ мощни функции за управление на кода и сътрудничество.

# Речник на термините в Git

## Основни термини и техните значения:

1. **Repo:**

   - Съхранява проекта на отдалечен сървър.

2. **Branch:**

   - Паралелен път за разработка (отделна версия на проекта).

3. **Merge branches:**

   - Обединява две версии на един и същ проект.

4. **Clone:**

   - Изтегляне на локално копие на отдалечен проект.

5. **Commit (комит):**

   - Запазва набор от промени локално.

6. **Pull:**

   - Взима и обединява промените от отдалечения репозиторий.

7. **Push:**
   - Изпраща локални промени към отдалечения репозиторий.

---

Тези термини са основата за работа с Git и улесняват управлението и сътрудничеството по проекти.

# GitHub

## Какво е GitHub?

1. **GitHub:**

   - Платформа и облачна услуга, изградена върху **Git**.
   - Най-използваният хостинг за изходен код в света.
   - Използва се за разработка на софтуер и контрол на версиите.
   - Безплатен за проекти с отворен код и малки частни проекти.
   - Платени планове с напреднали функции за частни репозитории.

2. **GitHub Desktop:**
   - Позволява взаимодействие с GitHub чрез графичен интерфейс (GUI), вместо използване на командния ред или уеб браузър.

---

GitHub е незаменим инструмент за разработчици, предоставящ мощни възможности за сътрудничество, управление на проекти и контрол на версиите.

# Функционалности на GitHub

GitHub предлага разнообразни инструменти и функции, които улесняват управлението на проекти, сътрудничеството и разработката на софтуер.

---

## Основни функционалности:

1. **Access Control:**

   - Управление на правата за достъп до репозитории.

2. **Bug Tracking:**

   - **Issue Tracker:** Инструмент за докладване и управление на грешки.

3. **Continuous Integration:**

   - **Actions:** Автоматизация на процеси като тестване и внедряване.

4. **Wiki Pages:**

   - Средство за създаване и поддържане на документация.

5. **Feature Requests:**

   - Позволява на потребителите да предлагат нови функции за проектите.

6. **Task Management:**

   - Организация и проследяване на задачи за проекта.

7. **Project Board:**

   - Управление на задачите в **Kanban стил** за по-добра визуализация.

8. **Etc.:**
   - GitHub разполага с множество други инструменти, които подобряват ефективността и сътрудничеството.

---

GitHub е пълноценна платформа за управление на проекти и съвместна разработка, която отговаря на нуждите на разработчиците.

# Основни Git команди

Работата с Git следва стандартен работен процес: **Клониране → Модифициране → Добавяне → Комитване → Изпращане (Push)**. Ето основните команди, които ще използвате:

---

## Команди за работа с Git:

1. **Клониране на съществуващ Git репозиторий:**

   - git clone [remote url]

2. **Изтегляне и сливане на последните промени от отдалечен репозиторий:**

   - git pull

3. **Добавяне на файлове за комит:**

   - git add [filename]

- За добавяне на всички файлове:

  - git add .

4. **Записване на промени в локалния репозиторий:**

   - git commit -m "[your message here]"

5. **Проверка на състоянието на локалния репозиторий:**

   - git status

6. **Създаване на нов локален репозиторий (в текущата директория):**

   - git init

7. **Създаване на отдалечен репозиторий:**

   - git remote add [remote name] [remote url]

8. **Изпращане на промените към отдалечения репозиторий:**

   - git push [remote name] [local branch name]

# Конфликти в Git и тяхното сливане

**Git конфликти** възникват, когато две или повече лица правят промени в един и същи файл едновременно. В такива случаи Git не може автоматично да определи коя промяна е правилната.

---

## Основни причини за конфликти:

1. **Едновременни промени в един и същи файл:**

   - Двама разработчици модифицират един и същ ред в един и същи файл.

2. **Изтриване на файл:**
   - Един разработчик изтрива файл, докато друг разработчик го модифицира.

---

## Какво се случва при конфликт?

- **Git не може да вземе автоматично решение:**
  - Не е ясно коя версия трябва да бъде приета.
- **Конфликтът засяга само разработчика, който провежда сливането:**
  - Останалите членове на екипа не са засегнати от конфликта.

---

## Как да разрешите конфликти?

При възникване на конфликт Git ще маркира проблемните области във файла. Разработчикът трябва ръчно да прегледа и реши конфликта, като избере правилната версия или комбинира промените.

Конфликтите са нормална част от работата в екип и могат да бъдат разрешени с добра комуникация и внимателен преглед на кода.

# Концепции за клонове и работа с тях в Git

**Клоновете (Branches)** в Git позволяват работа по различни части на проект, без да се засяга основният клон (**main/master**). Те предоставят гъвкавост и изолация за разработчиците.

---

## Какво представлява клонът (Branching)?

1. **Работа върху различни части на проект:**

   - Клоновете позволяват разработчиците да работят върху различни функции или задачи, без да влияят на основния клон.

2. **Абстракция за редактиране, подготовка и комитване:**

   - Клоновете предоставят отделна среда за редактиране, добавяне и записване на промени.

3. **Изолация на работата:**

   - Новите комити се записват в историята на текущия клон.
   - Промените не засягат основния клон, докато не се вземе решение за интеграция.

4. **Превключване между клонове:**
   - Разработчиците могат лесно да превключват между клонове и да работят по различни задачи, без те да си пречат взаимно.

---

## Основни ползи от използването на клонове:

- Изолация на работата, което позволява паралелно разработване на нови функции.
- Намаляване на риска от грешки в основния код.
- Възможност за лесно тестване на промени, преди те да бъдат обединени в основния клон.

---

Клоновете са основен инструмент за ефективна и организирана работа в Git проекти.

# Команди за работа с клонове в Git

Работата с клонове е основна част от управлението на проекти в Git. Ето как да преглеждате, превключвате и изтривате клонове.

---

## Команди за работа с клонове:

1. **Преглед на наличните клонове:**

   git branch

2. **Създаване на нов клон:**

   git branch [branch-name]

3. **Превключване към друг клон:**

   git checkout [branch-name]

   git switch [branch-name]

4. **Създаване и превключване към нов клон:**

   git checkout -b [branch-name]

   git switch -c [branch-name]

5. **Изтриване на клон:**

   git branch -d [branch-name]

   - Принудително изтриване (ако клонът не е обединен):

     git branch -D [branch-name]

## Работа с отдалечени клонове:

**Свързване на локален клон с отдалечен (upstream):**

git push --set-upstream [remote-name] [branch-name]

## Преглед на клонове

- **Списък на всички локални и отдалечени клонове:**

  git branch --all
  git branch -a

- **Списък на локалните клонове с последното съобщение за комит:**

  git branch --verbose
  git branch -vv

- **Списък на всички локални и отдалечени клонове с последното съобщение за комит:**

  git branch --all --verbose
  git branch -a -vv

- **Списък на локалните клонове:**

  git branch

## Работа с upstream и сливане

- **Изпращане на локален клон към нов upstream (в отдалечен клон):**

  git push --set-upstream origin {branch-name}
  git push -u origin {branch-name}

- **Сливане на друг клон в активния клон:**

  git merge {branch-name}

## Преработка и подбор на комити

- **Повторно прилагане на комити върху друга базова точка:**

  git rebase {base-branch-name}

- **Включване на конкретни комити без сливане на целия клон:**

  git cherry-pick {commit-hash}

## Git Squash

### Какво представлява Git Squash?

- **Комбиниране на множество комити в един:**  
  Полезно за изчистване на историята на комитите, преди да се слее feature клон с основния клон.

- **Предимства:**

  - Упрощава и прави историята на комитите по-лесна за разбиране.

- **Обичайни случаи на употреба:**
  - Използва се често заедно с други команди, като:
    ```bash
    git rebase
    git merge
    ```

---

### Внимание:

- **Пренаписва историята на комитите:**  
  Използвайте тази команда внимателно, тъй като може да доведе до загуба на данни, ако не се приложи правилно.

## Стратегии за работа с клонове

### Какво представлява стратегията за работа с клонове?

- **Стратегия за работа с клонове:**  
  Набор от правила, които програмистите следват при писане, сливане и внедряване на код, когато използват система за контрол на версиите (VCS).

- **Основни цели:**
  - Да създаде ясни правила за взаимодействие с общата кодова база.
  - Да позволи на екипите да работят паралелно, за да постигат по-бързи издания.
  - Да намали конфликтите, като осигури структуриран процес за правене на промени в изходния код.

---

### Ползи от стратегията за работа с клонове:

- Ускорява процеса на разработка.
- Осигурява по-добра координация в екипа.
- Минимизира възможността за конфликти при сливане на код.

## Цели на стратегията за работа с клонове

### Основни цели:

1. **Подобряване на продуктивността:**

   - Осигурява правилна координация между разработчиците.

2. **Организиране на издания:**

   - Помага за планиране и структуриране на поредица от издания.

3. **Ясна пътна карта за промени:**

   - Създава ясно дефиниран процес за внедряване на промени в софтуера от разработката до продукцията.

4. **Поддръжка на безгрешен код:**

   - Подпомага запазването на кода чист от грешки.

5. **Улесняване на паралелна разработка:**
   - Позволява на различни екипи да работят едновременно по различни функции или задачи.

## Чести стратегии за работа с клонове в Git

### Trunk-Based Development

- **Какво представлява?**

  - Стратегия "Без клонове".
  - Разработчиците интегрират своите промени директно в основния клон (**trunk**) поне веднъж на ден.

- **Основни принципи:**

  - Чести и малки промени, които се комитират директно в основния клон.
  - Основният клон трябва винаги да бъде готов за издание.

- **Кога е подходяща тази стратегия?**
  - Най-подходяща за по-опитни разработчици, които могат да управляват сложността и риска от директни промени в основния клон.

---

**Trunk-Based Development** предоставя бързина и ефективност, но изисква висока дисциплина и опит от страна на разработчиците.

## GitHub Flow

### Какво представлява GitHub Flow?

- **GitHub Flow:**
  - Лек и гъвкав процес за разработка.

---

### Основни принципи:

1. **Работа с отделни клонове:**

   - Всяка нова функционалност се разработва в собствен клон.

2. **Поддържане на основния код:**

   - Основният клон (**master**) се поддържа винаги в готово за внедряване състояние.

3. **Pull Requests и преглед на кода:**
   - Преди сливането всеки клон преминава през:
     - **Pull Request.**
     - Преглед на кода (Code Review).
     - Тестване и интеграция на промените.

---

**GitHub Flow** е подходящ за екипи, които търсят лек и структуриран процес за управление на своите разработки.

## GitFlow

### Какво представлява GitFlow?

- **GitFlow:**
  - Стратегия, която позволява паралелна разработка.

---

### Основни характеристики:

1. **Паралелна разработка:**

   - Разработчиците могат да работят отделно от основния клон (**master**) върху нови функционалности.

2. **Отделни и ясни клонове:**

   - Всеки клон има специфична цел (например за функции, издания или корекции).

3. **Управление на множество версии:**
   - Подходящ за проекти, които изискват поддръжка и развитие на няколко версии на продукта едновременно.

---

GitFlow предоставя структура и организация, което го прави идеален за сложни проекти с много разработчици.

## Клонове в GitFlow

GitFlow структурата включва няколко типа клонове, всеки със своя специфична роля в процеса на разработка и поддръжка.

---

### Видове клонове:

1. **Master (Main):**

   - Съдържа активния продукционен код.
   - Винаги е готов за издание.

2. **Release:**

   - Използва се за подготовка на ново издание за продукция.
   - Финалните тестове и настройки се извършват в този клон.

3. **Hotfix:**

   - Създава се при спешни ситуации, когато е открита грешка, която трябва незабавно да се коригира.
   - Произлиза директно от **Master**.

4. **Develop:**

   - Основният клон за разработка, в който се обединяват всички нови функции, преди да преминат към издание.

5. **Feature:**
   - Всеки разработчик работи върху нови функционалности в отделен **Feature** клон.
   - След завършване функционалността се обединява в **Develop**.

---

GitFlow предоставя ясна и организирана структура, която улеснява управлението на различните етапи от жизнения цикъл на проекта.

## GitLab Flow

### Какво представлява GitLab Flow?

- **GitLab Flow:**
  - Комбинира разработка, базирана на функционалности, с управление на клонове и проследяване на задачи (issue tracking).

---

### Основни характеристики:

1. **Функционалности в отделни клонове:**

   - Всяка нова функционалност се разработва в собствен клон.

2. **Работа с основния клон:**

   - Разработчиците работят директно с основния клон (**main**), който винаги е в готовност за внедряване.

3. **Внедряване в продукция:**
   - Основният клон може да бъде внедрен в продукция ръчно или автоматично.

---

GitLab Flow е подходящ за екипи, които искат да интегрират управлението на функционалности с ефективно внедряване в продукционна среда.

## Best Branching Strategy for Your Team

<img width="1581" alt="Best strategy" src="https://github.com/user-attachments/assets/dd4080c7-aeed-4df6-bedb-a4700b59d33f" />

## Няма "Стратегия за работа с клонове"

1. **Различни стратегии за различни организации:**

   - Всяка организация избира различна стратегия за работа с клонове според екипа и проекта.

2. **Няма "най-добра" стратегия за клонове:**

   - Изборът на стратегия зависи от специфичните нужди на проекта и екипа.

3. **Зависи от фактори като:**
   - **Екипът:** Неговият размер, структура и опит.
   - **Проектът:** Сложността и изискванията на текущата разработка.

---

Изборът на стратегия за клонове трябва да бъде гъвкав и съобразен с нуждите на проекта и работните процеси на екипа.

## Pull Requests в GitHub

### Какво представлява Pull Request?

- **Pull Request:**  
  Механизъм, чрез който разработчиците уведомяват своя екип, че са завършили дадена функционалност.

---

### Основни характеристики:

1. **Повече от обикновено уведомление:**

   - Pull Request служи и като процес за преглед на кода.
   - Позволява обсъждане на предложената функционалност.

2. **Обратна връзка:**

   - Ако има проблеми с промените, екипът може да оставя обратна връзка директно в Pull Request.

3. **Проследяване на активността:**
   - Всички дискусии и дейности, свързани с Pull Request, се проследяват в него.

---

Pull Requests са мощен инструмент за сътрудничество и гарантиране на качеството на кода в GitHub.

## Правила за защита на клонове (Branch Protection Rules)

### Какво представляват правилата за защита на клонове?

- **Branch Protection Rules:**
  - Механизъм за създаване на правила за защита на клоновете в даден репозиторий.

---

### Какво можете да защитите?

1. **Конкретен клон:**

   - Създаване на правила за защита на определен клон, например **main**.

2. **Всички клонове:**

   - Прилагане на правила за защита към всички клонове в репозитория.

3. **Клонове, съвпадащи с шаблон:**
   - Използване на **fnmatch** синтаксис за създаване на правила, които се прилагат към клонове със специфични имена.
   - Пример: Защита на всички клонове, чиито имена започват с "feature/".

---

### Пример за приложение:

- **Забрана за сливане без одобрен Pull Request:**
  - Създаване на правило, което предотвратява сливането в даден клон, докато не бъде одобрен Pull Request.

---

Правилата за защита на клоновете гарантират качеството и последователността на кода, като предотвратяват нежелани промени.

## The Pull Request Process

<img width="1581" alt="The Pull Request Process" src="https://github.com/user-attachments/assets/6489fe1d-d9fb-4793-b834-cc8d833be59e" />

## Форкване в GitHub

### Какво е форкване?

- **Fork:**
  - Лично копие на репозиторий на друг потребител във вашия GitHub акаунт.
  - Позволява правене на промени, без да се засяга оригиналният проект.

---

### Основни характеристики:

1. **Свързаност с оригинала:**

   - Форкнатият репозиторий остава свързан с оригиналния, което позволява актуализации и допринасяне чрез Pull Requests.

2. **Безопасност за оригиналния проект:**
   - Всички промени се извършват във форкнатото копие, без да засягат оригиналния код.

---

### Чести приложения:

1. **Принос към проекти с отворен код:**

   - Форкването е често използвано за сътрудничество в общности с отворен код.

2. **Изучаване и модифициране на съществуващ код:**
   - Разработчиците могат безопасно да експериментират с кода, без риск за оригинала.

---

Форкването е мощен инструмент за сътрудничество и учене в GitHub.

## Fork vs. Branch

<img width="1539" alt="Fork vs  Branch" src="https://github.com/user-attachments/assets/e37ae508-2a3b-4f44-98c9-6d954e7765c8" />

## Обобщение

- **Git:**  
  Разпределена система за контрол на версиите.

- **GitHub:**  
  Платформа и облачна услуга, базирана на Git.

- **Клон (Branch):**  
  Отделна версия на основния репозиторий.

- **Стратегия за клонове:**  
  Изградете своята стратегия, използвайки няколко основни концепции.

- **Pull Requests:**  
  Позволяват да информирате другите за направените промени в даден клон на репозиторий в GitHub.

- **Конфликти:**  
  Могат да възникнат при сливане на клонове.

- **Forking:**  
  Метод за създаване на собствено копие на репозиторий, което ви позволява да правите промени, без да засягате оригинала.

---

# 03. Automated Testing

## Software Testing, Test Automation, Types of Tests

## Software Testing

### Какво представлява тестването?

- **Тестването** е ключова част от жизнения цикъл на разработка на приложения.
- Новите функционалности трябва да бъдат проверени, преди да бъдат доставени на клиентите.

---

### Основни аспекти на тестването:

1. **Широк обхват:**

   - Тестването обхваща множество аспекти на разработката на приложения.

2. **Нива и типове тестване:**

   - Съществуват различни нива, концепции и видове тестване.

3. **Съответствие с изискванията:**

   - Проверява дали разработеният софтуер отговаря на функционалните и нефункционалните изисквания.

4. **Откриване на дефекти:**
   - Основната цел на тестването е да открива и докладва дефекти (бъгове).

---

## Importance of Software Testing

### Основни предимства:

1. **Осигурява качество:**

   - Гарантира, че продуктът отговаря на изискванията и стандартите за качество.

2. **Помага за откриване на грешки:**

   - Идентифицира дефекти и бъгове, които могат да повлияят на функционалността.

3. **Намалява рисковете:**

   - Предотвратява потенциални проблеми, които могат да възникнат в продукционна среда.

4. **Икономически ефективно:**

   - Откриването и поправянето на бъгове в ранните етапи на разработка спестява разходи в дългосрочен план.

5. **Гарантира съответствие:**

   - Уверява, че продуктът отговаря на изискванията и регулациите.

6. **Подобрява процесите:**
   - Подпомага непрекъснатото усъвършенстване на процеса на разработка.

Тестването не само гарантира качество, но също така създава основа за по-ефективен и усъвършенстван процес на разработка.

---

## The Software Testing Process

Процесът на тестване включва няколко основни етапа, които гарантират качеството и ефективността на софтуера.

### Основни етапи:

1. **Планиране на тестването (Test Planning):**

   - Определяне на какво, кога и как ще се тества.

2. **Дизайн на тестове (Test Design):**

   - Създаване на тестови сценарии и тестови случаи.

3. **Настройка на тестовата среда (Setup Test Environment):**

   - Инсталиране, конфигуриране и подготовка на тестови данни.

4. **Изпълнение на тестовете (Test Execution):**

   - Провеждане на планираните тестове.

5. **Докладване на тестовете (Test Reporting):**
   - Регистриране на резултатите от тестовете и откритите бъгове.

Структурираният процес на тестване е ключов за успешното идентифициране и коригиране на проблемите в софтуера.

<img width="707" alt="STLC" src="https://github.com/user-attachments/assets/9052d0ae-0045-4fbb-859a-1aa2c4996e81" />

---

## Manual and Automation Testing

### Ръчно тестване (Manual Testing)

- **Какво представлява:**

  - Тип тестване, при което тестовете се изпълняват ръчно, без използване на автоматизирани инструменти.

- **Основни характеристики:**
  - Извършва се от човек, който следва стъпка по стъпка процес без използване на тестови скриптове.
  - Тестовете се изпълняват един по един, индивидуално.

---

### Автоматизирано тестване (Automation Testing)

- **Какво представлява:**

  - Тип тестване, при което тестовете се изпълняват автоматично чрез рамки за автоматизация на тестове.

- **Основни характеристики:**
  - Използват се инструменти и скриптове за автоматизиране на тестовите усилия.
  - Изисква кодиране и поддръжка на тестовете.

Ръчното тестване е подходящо за по-прости тестови сценарии, докато автоматизираното тестване предоставя ефективност и мащабируемост за по-сложни процеси.

---

## Different Levels of Software Testing

Тестването на софтуер се извършва на различни нива, всяко от които е насочено към специфични аспекти на разработката.

---

### 1. **Unit Tests (Юнит тестове):**

- **Какво тестват:**
  - Индивидуални компоненти или модули от софтуера.
- **Кой ги създава:**
  - Обикновено се създават от разработчиците.

---

### 2. **Integration Tests (Интеграционни тестове):**

- **Какво тестват:**
  - Взаимодействието между различни компоненти (например API-та).
- **Кой ги създава:**
  - Създават се както от разработчиците, така и от QA инженерите за автоматизация.

---

### 3. **System Tests / End-to-End Tests (Системни тестове / Тестове от край до край):**

- **Какво тестват:**
  - Цялостната система като едно цяло.
- **Кой ги създава:**
  - Създават се от QA инженерите за автоматизация.

Всяко ниво на тестване има своята роля и значение за осигуряване на качеството и стабилността на софтуера.

---

## Test Driven Development - TDD

### Какво представлява TDD?

- **TDD:**
  - Подход към разработката, при който тестовите случаи се създават **преди** писането на самия код.
  - Помага за избягване на дефекти и прави кода по-ясен и структуриран.

---

### Основни стъпки в TDD:

1. **Създаване на тест:**

   - Напишете тестовия случай, който определя желаното поведение на кода.

2. **Стартиране на теста:**

   - Изпълнете теста, за да потвърдите, че той не преминава (очаквано, защото кодът все още не е написан).

3. **Писане на кода:**

   - Напишете минималния код, необходим за успешното преминаване на теста.

4. **Стартиране на теста отново:**

   - Уверете се, че тестът преминава успешно след добавянето на кода.

5. **Рефакториране:**
   - Подобрете кода, като запазите теста успешен.

TDD е мощен метод, който гарантира по-високо качество на кода и намалява вероятността от дефекти в по-късните етапи на разработка.

---

## Bug Tracking Software

### Какво представляват инструментите за проследяване на бъгове?

- Инструментите за проследяване на бъгове са от съществено значение за управлението и поддръжката на списъка с бъгове, открити по време на тестване на софтуера.

---

### Основни функции:

1. **Лесно докладване на дефекти:**

   - Удобен интерфейс за съобщаване на бъгове.

2. **Категоризация и приоритизация:**

   - Позволяват класифициране на бъговете и определяне на тяхната важност.

3. **Документиране на стъпки:**

   - Включват функции за записване на стъпките за възпроизвеждане на даден бъг.

4. **Проследяване на историята и напредъка:**
   - Позволяват следене на хронологията и статуса на всеки бъг.

---

### Популярни инструменти:

- **JIRA**
- **Bugzilla**
- **Trello**
- **Asana**
- **GitHub**

Инструментите за проследяване на бъгове улесняват екипите да управляват ефективно процеса на откриване и отстраняване на дефекти.

---

## Test Levels

### Основни нива на тестване:

1. **Unit Tests (Юнит тестове):**

   - **Какво тестват:**
     - Индивидуални компоненти (функции или методи), за да се уверим, че работят коректно в изолация.

2. **Integration Tests (Интеграционни тестове):**

   - **Какво тестват:**
     - Взаимодействието между компонентите, за да се провери дали работят заедно според очакванията.

3. **System Tests (Системни тестове):**

   - **Какво тестват:**
     - Цялостния и интегриран софтуер, за да се гарантира, че отговаря на изискванията на клиента.

4. **Acceptance Tests (Тестове за приемане):**
   - **Какво тестват:**
     - Потвърждават цялостния бизнес процес от край до край.
     - Извършват финална проверка, за да се гарантира, че системата отговаря на бизнес нуждите.

Тези нива на тестване обхващат всички аспекти от разработката и осигуряват надеждността на софтуера.

---

# The Testing Pyramid

<img width="1541" alt="Testing Pyramid" src="https://github.com/user-attachments/assets/328aad11-191b-4c3a-99e5-9e8ef66f9bda" />

---

# Test Types

<img width="1541" alt="Test Types" src="https://github.com/user-attachments/assets/19bda28e-7d5c-4f75-a59b-ea1ac85af9cb" />

---

<img width="1541" alt="Any Level" src="https://github.com/user-attachments/assets/25a4c93c-486d-40dd-b49c-68f130174c1e" />

---

## Test Case

### Какво представлява тестовият случай?

- **Тестов случай:**
  - Набор от стъпки, условия и входни данни, използвани за тестване на софтуерна система с цел да се провери дали тя функционира правилно.

---

### Видове тестови случаи:

1. **Позитивен тест:**

   - Проверява дали системата работи правилно при очаквани входни данни.

2. **Негативен тест:**
   - Проверява как системата се справя с неочаквани или некоректни входни данни.

---

### Основни компоненти на тестовия случай:

1. **Заглавие (+ по желание описание):**

   - Кратко обобщение на целта на теста.

2. **Стъпки за изпълнение:**

   - Подробно описание на действията, които трябва да се извършат.

3. **Очакван резултат:**
   - Резултатът, който се очаква, ако системата работи правилно.

Тестовите случаи са основа за структурирано тестване, осигурявайки систематичен подход към проверката на софтуера.

---

## Test Scenarios and Test Cases – Example

<img width="1541" alt="Test case example" src="https://github.com/user-attachments/assets/9d1c0837-c7ba-4381-b423-0b1648591429" />

## Test Case – Formal Example

<img width="1555" alt="Formal example" src="https://github.com/user-attachments/assets/b12fe2f9-f0ab-4171-8438-37dc8fd19816" />

---

## Test Automation

### Какво представлява автоматизираното тестване?

- **Автоматизираното тестване** е ключова част от разработката на софтуер.
- Извършва се на различни нива:
  - **Юнит тестове (Unit Tests)**
  - **Интеграционни тестове (Integration Tests)**
  - **UI тестове**

---

### Инструменти за автоматизирано тестване:

1. **Тестови рамки (Frameworks):**

   - Примери: **JUnit, NUnit, Mocha**

2. **Инструменти за автоматизация:**

   - Примери: **Selenium, Appium, Sikuli**

3. **Типове тестване:**
   - Тестване на уеб приложения.
   - Тестване на API.
   - Тестване на мобилни приложения.

---

### Ползи от автоматизираното тестване:

1. **Подобрена точност:**

   - Елиминира човешките грешки при изпълнение на тестове и оценка на резултатите.

2. **По-бърза обратна връзка:**

   - Позволява бързо изпълнение на тестове и предоставя незабавна информация за качеството на софтуера.

3. **По-голям обхват на тестване:**

   - Позволява тестване на различни сценарии, намалявайки риска от пропускане на критични тестови случаи.

4. **Непрекъснато тестване:**
   - Намалява нуждата от ресурси за повтарящо се ръчно тестване.

Автоматизираното тестване оптимизира процеса на проверка и гарантира по-бърза и надеждна доставка на качествен софтуер.

---

## Integration Testing

### Какво представлява интеграционното тестване?

- **Интеграционно тестване** проверява взаимодействието между няколко компонента, тествани заедно като група.
- Целта е да се разкрият дефекти във взаимодействието между интегрираните модули.

---

### Основни характеристики:

1. **Комбиниране на модули:**

   - Съединява отделни модули и проверява тяхната работа заедно.

2. **Проверка на взаимодействието:**
   - Проверява как добре индивидуалните части функционират заедно.

---

### Как се изпълнява интеграционно тестване?

- **Чрез тестови рамки (Testing Frameworks):**

  - Използват се инструменти за автоматизация, за да се изпълнят тестовете.

- **Чрез използване на стъбове (stubs) и мокс (mocks):**
  - **Stubs:** Заместители за реални модули, които връщат фиксирани отговори.
  - **Mocks:** Емулират поведението на реални обекти за проверка на взаимодействието.

Интеграционното тестване е ключово за осигуряване на коректното взаимодействие между компонентите и стабилността на цялостната система.

---

## Подходи за интеграционно тестване

### Основни подходи:

1. **Top-Down:**

   - Тестването започва от върха на контролния поток или архитектурната структура.

2. **Bottom-Up:**

   - Тестването започва от дъното на контролния поток или архитектурната структура.

3. **Hybrid (Хибриден подход):**

   - Комбинира **Top-Down** и **Bottom-Up** подходите.

4. **Big Bang:**
   - Всички модули се тестват едновременно като едно цяло.

---

## Роля в жизнения цикъл на разработка на софтуер (SDLC)

1. **Кога се изпълнява?**

   - Провежда се след **юнит тестове** и преди **системни тестове**.

2. **Цели и ползи:**

   - Идентифицира проблеми, които възникват при взаимодействието на отделни модули.
   - Осигурява плавна интеграция между компонентите.
   - Улеснява локализирането на грешки.
   - Подобрява обхвата на тестване.

3. **Инкрементален подход:**
   - Тестват се два модула едновременно → добавя се трети → след това четвърти и т.н.

Интеграционното тестване е от съществено значение за идентифициране на проблеми във взаимодействията между модули и за осигуряване на тяхната съвместимост.

---

## Unit vs. Integration Testing

<img width="1461" alt="Unit vs Integration" src="https://github.com/user-attachments/assets/f371311d-8053-4617-91c4-43c6c215c199" />

---

## Популярни тестови рамки (Frameworks)

1. **C# (ASP.NET Core):**

   - **xUnit**
   - **nUnit**
   - **Moq**

2. **Java (Spring):**

   - **JUnit**
   - **Spring Test**
   - **Mockito**

3. **JavaScript (Node.js/React/Vue):**

   - **Jest**
   - **Mocha** (и **Chai**)
   - **Cypress**

4. **Python:**
   - **Pytest**
   - **unittest**
   - **Django Test Framework**

Тези рамки предоставят мощни инструменти за различни езици и технологии, като улесняват писането и изпълнението на тестове.

---

## API Тестване

### Какво представлява API тестването?

- **API тестването** проверява API директно или като част от интеграционното тестване.
- Критично за проверка на:
  - Бизнес логиката.
  - Взаимодействията между различни услуги.
  - Микросервизите.
  - API на трети страни.

---

### Цели на API тестването:

1. **Функционалност:**

   - Проверява заявки, отговори, крайни точки, грешки и др.

2. **Надеждност:**

   - Тестване на стабилността на връзката.

3. **Производителност:**

   - Оценка на времето за отговор при различни условия.

4. **Сигурност:**
   - Проверява автентикация, разрешения и контроли за достъп.

---

### Основни типове API тестване:

1. **Функционално тестване:**

   - Проверява дали API изпълнява очакваните операции.

2. **Натоварване и производителност:**

   - Измерва как API се справя при стрес или висок трафик.

3. **Сигурност:**

   - Гарантира, че API е защитен срещу уязвимости.

4. **Негативно тестване:**
   - Тестване как API обработва невалидни входни данни или неочаквани ситуации.

---

### Ползи от API тестването:

- **Ранно откриване на бъгове** в бизнес логиката.
- Лесна интеграция между компонентите.
- **Подобрено покритие на тестовете.**
- По-бързо тестване, без нужда от UI.
- **Независимост от език:**
  - Обмен на данни чрез **XML** или **JSON**.
  - Входове и изходи се обработват чрез **HTTP**.
- Увеличена сигурност на приложенията.
- Поддържа **Agile** и **CI/CD** методологии.

---

### Популярни инструменти за API тестване:

1. **Postman:**

   - Използва се за ръчно и автоматизирано тестване.

2. **Swagger / OpenAPI:**

   - Генериране на API документация и създаване на автоматизирани тестове.

3. **RestAssured:**

   - Инструмент за тестване на RESTful API.

4. **Newman:**
   - Команден инструмент за изпълнение на Postman колекции в CI/CD тръбопроводи.

API тестването осигурява ефективност, сигурност и надеждност на приложенията, като улеснява процеса на разработка.

---
